---
layout: post
title:  "Cryptography: Cracking Codes"
date:   2016-10-10 22:41:19 -0500
categories: Coursera
---

I did the problem below as an optional programming assignment for the course Cryptography on Coursera, offered by the University of Maryland in their Cybersecurity Specialization.

#### Problem Statement:
*Numbered below are 7 ciphertexts, each of which was generated by encrypting some 31-character ASCII plaintext with the one-time pad using the same key (code for the encryption program used is given below). Decrypt them and recover all 7 plaintexts, each of which is a grammatically correct English sentence. Note: for this problem it is easiest to use a combination of automated analysis plus human insight and even occasional guessing. As long as you can decrypt them all, it doesn't matter how you do it.*
 
 
`1. BB 3A 65 F6 F0 03 4F A9 57 F6 A7 67 69 9C E7 FA BA 85 5A FB 4F 2B 52 0A EA D6 12 94 4A 80 1E`
 
`2. BA 7F 24 F2 A3 53 57 A0 5C B8 A1 67 62 C5 A6 AA AC 92 4A E6 44 7F 06 08 A3 D1 13 88 56 9A 1E`
 
`3. A6 72 61 BB B3 06 51 BA 5C F6 BA 29 7E D0 E7 B4 E9 89 4A A9 5E 30 02 47 F0 C0 02 8F 40 9A 1E`
 
`4. A5 72 61 F5 F0 00 4B A7 4C F4 AA 29 79 D9 A6 B7 AC 85 4D A9 5E 30 52 03 EC 85 15 95 4C 9D 0F`
 
`5. BB 3A 70 F3 B9 1D 48 E8 4D F0 AB 70 2E CF EE B5 BC 8C 5D A9 4C 30 1E 0B EC D2 41 95 4C 83 1E`
 
`6. A6 72 6D E8 F0 1A 50 E8 49 ED BC 6C 7C 9C F2 B2 A8 8E 19 FD 42 3E 06 47 EC CB 04 DD 4C 9D 1E`
 
`7. BC 75 70 BB BF 1D 46 E8 5A F9 AA 6C 7A 9C EF A9 E9 82 5C FD 5E 3A 00 47 F7 CD 00 93 05 A7 1E`
 
*Here is the code of the encryption program:*

{% highlight c++ %}

#include 
#define KEY_LENGTH 31
 
main(){
  unsigned char ch;
  FILE *fpIn, *fpOut;
  int i;
  unsigned char key[KEY_LENGTH] = {0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00};
  // Of course, I did not use the all-0 key when generating the 7 ciphertexts above!
 
  fpIn = fopen("messages.txt", "r");
  fpOut = fopen("ctexts.txt", "w");
 
  i=0;
 
  while (fscanf(fpIn, "%c", &ch) != EOF) {
    fprintf(fpOut, "%02X", ch^key[i]);
    i++;
    if (i==31) {
      fprintf(fpOut, "\n");
      i=0;
      fscanf(fpIn, "%c", &ch);
    }
  }
 
  fclose(fpIn);
  fclose(fpOut);
 
  return;
}
{% endhighlight %}

This problem gave me unusual excitement, because quite honestly I really enjoy cracking codes. It's like you're in a detective movie :)
 
After reading the encryption code (it basically XORed each character of the key with the corresponding character of the plaintexts), I decided to look over the ciphertexts to see if there was any pattern a human could recognize. It was pretty easy to see that the last character of 6 out of 7 ciphertexts was all `0x1E` except for (4) with `0x0F`. Because they were all grammatically correct English sentences, I guessed that `0x1E` stood for the period (.) and `0x0F` stood for the question mark (?). And so I broke the last byte of the key, which was `0x30`.
 
Now... I was stuck.
 
The rest of the ciphertexts made little sense. For a while I tried (stupidly) to find other patterns, but there were none. Then I suddenly realized that because they all used the same 31-byte key, and they were all English sentences, the characters must be either space (ASCII decimal #32), or uppercase letters (ASCII decimal #65-90), or lowercase letters (ASCII decimal #97-122). I excluded punctuations to prevent diluting the results, since most of the characters in the sentences would be English letters and spaces anyway. If I could figure out enough letters, I could use them to infer what the others were. 
 
So I wrote a little code in C++ that tried every possible character from `0x00` to `0xFF` as key to XOR against each character of the 7 ciphertexts to see which one resulted in the desired ASCII ranges above, then output that key character and the corresponding decrypted characters. Below is an example screenshot of the raw output (this means for the 4th character of every ciphertext, the only key that works is `0x9b` which produces letter `m` for ciphertext (1), letter `i` for ciphertext (2), and so forth at that position. For the 7th character, there are many possibilities):

![alt text]({{ site.url }}\assets\images\20161010cracking1.png)

...and partial & complete outputs (after I did some manual fill-in-the-blanks):

![alt text]({{ site.url }}\assets\images\20161010cracking2.png)


So there it was! The key in hexadecimal is:
 
`key[31] = {0xf2, 0x1a, 0x04, 0x9b, 0xd0, 0x73, 0x23, 0xc8, 0x39, 0x98, 0xce, 0x09, 0x0e, 0xbc, 0x86, 0xda, 0xc9, 0xe0, 0x39, 0x89, 0x2a, 0x5f, 0x72, 0x67, 0x83, 0xa5, 0x61, 0xfd, 0x25, 0xee, 0x30};`
 
You can find the code I wrote below:

{% highlight c++ %}

#include <iostream>
using namespace std;
 
int main() {
// ciphertexts
    unsigned char ciphertext[7][31] = {
{0xBB, 0x3A, 0x65, 0xF6, 0xF0, 0x03, 0x4F, 0xA9, 0x57, 0xF6, 0xA7, 0x67, 0x69, 0x9C, 0xE7, 0xFA, 0xBA, 0x85, 0x5A, 0xFB, 0x4F, 0x2B, 0x52, 0x0A, 0xEA, 0xD6, 0x12, 0x94, 0x4A, 0x80, 0x1E},
 
{0xBA, 0x7F, 0x24, 0xF2, 0xA3, 0x53, 0x57, 0xA0, 0x5C,0xB8, 0xA1, 0x67, 0x62, 0xC5, 0xA6, 0xAA, 0xAC, 0x92, 0x4A, 0xE6, 0x44, 0x7F, 0x06, 0x08, 0xA3, 0xD1, 0x13, 0x88, 0x56, 0x9A, 0x1E},
 
{0xA6, 0x72, 0x61, 0xBB, 0xB3, 0x06, 0x51, 0xBA, 0x5C, 0xF6, 0xBA, 0x29, 0x7E, 0xD0, 0xE7, 0xB4, 0xE9, 0x89, 0x4A, 0xA9, 0x5E, 0x30, 0x02, 0x47, 0xF0, 0xC0, 0x02, 0x8F, 0x40, 0x9A, 0x1E},
 
{0xA5, 0x72, 0x61, 0xF5, 0xF0, 0x00, 0x4B, 0xA7, 0x4C, 0xF4, 0xAA, 0x29, 0x79, 0xD9, 0xA6, 0xB7, 0xAC, 0x85, 0x4D, 0xA9, 0x5E, 0x30, 0x52, 0x03, 0xEC, 0x85, 0x15, 0x95, 0x4C, 0x9D, 0x0F},
 
{0xBB, 0x3A, 0x70, 0xF3, 0xB9, 0x1D, 0x48, 0xE8, 0x4D, 0xF0, 0xAB, 0x70, 0x2E, 0xCF, 0xEE, 0xB5, 0xBC, 0x8C, 0x5D, 0xA9, 0x4C, 0x30, 0x1E, 0x0B, 0xEC, 0xD2, 0x41, 0x95, 0x4C, 0x83, 0x1E},
 
{0xA6, 0x72, 0x6D, 0xE8, 0xF0, 0x1A, 0x50, 0xE8, 0x49, 0xED, 0xBC, 0x6C, 0x7C, 0x9C, 0xF2, 0xB2, 0xA8, 0x8E, 0x19, 0xFD, 0x42, 0x3E, 0x06, 0x47, 0xEC, 0xCB, 0x04, 0xDD, 0x4C, 0x9D, 0x1E},
 
{0xBC, 0x75, 0x70, 0xBB, 0xBF, 0x1D, 0x46, 0xE8, 0x5A, 0xF9, 0xAA, 0x6C, 0x7A, 0x9C, 0xEF, 0xA9, 0xE9, 0x82, 0x5C, 0xFD, 0x5E, 0x3A, 0x00, 0x47, 0xF7, 0xCD, 0x00, 0x93, 0x05, 0xA7, 0x1E}
    };
 
// This outputs all possible candidates for each character of each ciphertext
    cout << "------------ Raw result: --------" << endl;
    char plaintext[7][31];
    for (int j = 0; j < 31; j++) {
        cout << dec << j + 1 << "---\n";
        int count = 0;
        for (int k = 0; k < 256; k++) {
            bool flag = true;
            for (int i = 0; i < 7; i++) {
// If the result is not in the desired ASCII range, break and move on to next key
                int check = (int) (ciphertext[i][j] ^ k);
                if ( (check < 65 && check != 32) ||
                     (check > 90 && check < 97) ||
                     (check > 122)) {
                        flag = false;
                        break;
                }
            }
 
// If this key produces a match, output the results (maybe wrong)
            if (flag) {
                cout << hex << k << ": ";
                for (int i = 0; i < 7; i++) {
                    cout << i + 1 << "." <<
                        (char) ((int) ciphertext[i][j] ^ k) << " ";
                    plaintext[i][j] = (char) ((int) ciphertext[i][j] ^ k);
                }
                cout << endl;
                count++;
            }
        }
        cout << endl;
// If there are more than one possibility, set that character of
// plaintext to (_) to denote unfilled blanks
        if (count > 1) {
            for (int i = 0; i < 7; i++) {
                plaintext[i][j] = '_';
            }
         }
    }
 
// Print out the partial results with some blanks unfilled in the plaintexts
    cout << "----------- Partial result: -----" << endl;
    for (int i = 0; i < 7; i++) {
        cout << i + 1 << ". ";
        for (int j = 0; j < 31; j++) {
            cout << plaintext[i][j];
        }
        cout << "\n \n";
    }
 
// This key is what I got after doing some manual fill-in-the-blanks
    cout << "----------- Full result: --------" << endl;
    unsigned char key[31] = {0xf2, 0x1a, 0x04, 0x9b, 0xd0, 0x73, 0x23, 0xc8, 0x39,
0x98, 0xce, 0x09, 0x0e, 0xbc, 0x86, 0xda, 0xc9, 0xe0,
0x39, 0x89, 0x2a, 0x5f, 0x72, 0x67, 0x83, 0xa5, 0x61,
0xfd, 0x25, 0xee, 0x30};
    for (int i = 0; i < 7; i++) {
        cout << i + 1 << ". ";
        for (int j = 0; j < 31; j++) {
            cout << (char) ((int) ciphertext[i][j] ^ key[j]);
        }
        cout << endl;
    }  
 
    return 0;
}

{% endhighlight %}
